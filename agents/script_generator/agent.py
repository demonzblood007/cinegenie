"""
Script Generator Agent
Generates a 3â€“5 part script for reels/shorts based on movie memory and fan desires
"""

import logging
from typing import Dict, Any, List
from core.config import Settings
from core.models import ScriptData, MovieData, TrendAnalysis
import openai
import uuid
from datetime import datetime

logger = logging.getLogger(__name__)

class ScriptGeneratorAgent:
    def __init__(self, settings: Settings):
        self.settings = settings
        self.llm_provider = settings.get_llm_provider()
        self.max_parts = 5

    async def initialize(self):
        logger.info("Initializing Script Generator Agent...")
        # Optionally, load prompt templates or style guides
        logger.info("Script Generator Agent initialized.")

    async def generate_script(self, movie_data: MovieData, trend_data: TrendAnalysis) -> ScriptData:
        logger.info(f"Generating script for: {movie_data.title}")
        # Prepare context
        context = self._build_context(movie_data, trend_data)
        # Generate script parts
        parts = []
        for i in range(self.max_parts):
            part = await self._generate_script_part(context, part_num=i+1)
            parts.append(part)
        # Compose ScriptData
        script_id = str(uuid.uuid4())
        script_data = ScriptData(
            movie_title=movie_data.title,
            script_type="continuation",
            total_parts=self.max_parts,
            parts=parts,
            main_characters=[c['name'] for c in movie_data.characters],
            story_arc="Fan-fulfillment arc",
            emotional_tone=movie_data.tone,
            target_duration=self.settings.video_max_duration,
            fan_desire_alignment=trend_data.viral_potential_score,
            viral_potential=trend_data.viral_potential_score,
            generation_timestamp=datetime.now()
        )
        logger.info(f"Script generated for: {movie_data.title}")
        return script_data

    def _build_context(self, movie_data: MovieData, trend_data: TrendAnalysis) -> str:
        """Builds a context string for the LLM prompt"""
        context = f"""
Movie Title: {movie_data.title}
Plot Summary: {movie_data.plot_summary}
Main Characters: {', '.join([c['name'] for c in movie_data.characters])}
Themes: {', '.join(movie_data.themes)}
Tone: {movie_data.tone}
Ending Summary: {movie_data.ending_summary}
Unresolved Plot Points: {', '.join(movie_data.unresolved_plot_points)}
Fan Favorite Scenes: {', '.join(movie_data.fan_favorite_scenes)}

Fan Desires (from reviews): {', '.join(trend_data.fan_desires)}
Most Anticipated Continuations: {', '.join(trend_data.most_anticipated_continuations)}
Viral Potential Score: {trend_data.viral_potential_score}
Target Audience: {', '.join(trend_data.target_audience)}
"""
        return context

    async def _generate_script_part(self, context: str, part_num: int) -> Dict[str, Any]:
        """Generate a single part of the script using the LLM"""
        prompt = (
            f"You are a Hollywood scriptwriter. Given the following context, write PART {part_num} of a 5-part cinematic short arc (Intro, Conflict, Climax, Resolution). "
            "Each part should be concise, high-emotion, and match the original movie's tone. "
            "Continue the most-wanted storyline as desired by fans.\n\n"
            f"Context:\n{context}\n\n"
            f"PART {part_num}:"
        )
        try:
            if self.llm_provider == "openai":
                response = openai.ChatCompletion.create(
                    model="gpt-4-turbo",
                    messages=[{"role": "user", "content": prompt}],
                    max_tokens=600
                )
                content = response['choices'][0]['message']['content']
            else:
                # Placeholder for other LLM providers
                content = f"[Script part {part_num} generated by {self.llm_provider}]"
            return {
                "part_num": part_num,
                "text": content.strip(),
                "structure": self._infer_structure(part_num)
            }
        except Exception as e:
            logger.error(f"Script generation failed for part {part_num}: {e}")
            return {
                "part_num": part_num,
                "text": f"[Failed to generate part {part_num}]",
                "structure": self._infer_structure(part_num)
            }

    def _infer_structure(self, part_num: int) -> str:
        if part_num == 1:
            return "Intro"
        elif part_num == self.max_parts:
            return "Resolution"
        elif part_num == self.max_parts - 1:
            return "Climax"
        elif part_num == 2:
            return "Conflict"
        else:
            return "Development"

    async def get_status(self):
        return {"agent_name": "script_generator", "status": "healthy"}

    async def cleanup(self):
        logger.info("Script Generator Agent cleanup completed.") 